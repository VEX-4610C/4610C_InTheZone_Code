#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, in1,    clawPot,        sensorPotentiometer)
#pragma config(Sensor, in3,    gyro,           sensorGyro)
#pragma config(Sensor, in4,    right2,         sensorLineFollower)
#pragma config(Sensor, in5,    right1,         sensorLineFollower)
#pragma config(Sensor, in6,    left1,          sensorLineFollower)
#pragma config(Sensor, in7,    left2,          sensorLineFollower)
#pragma config(Sensor, dgtl2,  liftLimit,      sensorTouch)
#pragma config(Sensor, I2C_1,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_2,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_3,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_4,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_5,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Motor,  port3,           frontRight,    tmotorVex393_MC29, openLoop, reversed, encoderPort, I2C_1)
#pragma config(Motor,  port4,           backRight,     tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port5,           elevator,      tmotorVex393_MC29, openLoop, encoderPort, I2C_3)
#pragma config(Motor,  port6,           liftLeft,      tmotorVex393_MC29, openLoop, encoderPort, I2C_5)
#pragma config(Motor,  port7,           liftRight,     tmotorVex393_MC29, openLoop, reversed, encoderPort, I2C_4)
#pragma config(Motor,  port8,           backLeft,      tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port9,           frontLeft,     tmotorVex393_MC29, openLoop, encoderPort, I2C_2)
#pragma config(Motor,  port10,          claw,          tmotorVex393_HBridge, openLoop, reversed)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/*---------------------------------------------------------------------------*/
/*                                                                           */
/*        Description: Competition template for VEX EDR                      */
/*                                                                           */
/*---------------------------------------------------------------------------*/

// This code is for the VEX cortex platform
#pragma platform(VEX2)

// Select Download method as "competition"
#pragma competitionControl(Competition)

//Main competition background code...do not modify!
#include "Vex_Competition_Includes.c"

#define resetButton vexRT[Btn7R]


int sign(int x)
{
	if(x < 0)
		return -1;
	return 1;
}
/* float map(float x, float in_min, float in_max, float out_min, float out_max)
{
return (x - in_min) * (out_max - out_min) / (in_max - in_min) + out_min;
} */
// Config Parameters
int liftBottom = 0;
int liftPreload = 160;
int liftCloseClaw = 585;
int liftGoal = 0;
int liftDone = 0;
int curStacked = 0;
int stackLevels[6] = {650, 600, 565, 540, 540, 535};

int clawOpen = 2500;
int clawClose = 2900;
int clawGoal = 2300;
int clawDone = 0;

int elevatorGoal = 0;
int elevatorTop = 0;
int elevatorBottom = 750;
int elevatorDone = 0;
void degmove(int distance)
{
	nMotorEncoder[frontLeft] = 0;
	distance *= 15;
	if(distance > 0) // move forward
	{
		while(abs(nMotorEncoder[frontLeft]) < distance)
		{
			motor[frontLeft] = motor[backLeft] = (abs(nMotorEncoder[frontLeft] - distance) * .2 + 65);
			motor[frontRight] = motor[backRight] = abs(nMotorEncoder[frontLeft] - distance) * .2 + 65;
		}
		motor[frontLeft] = motor[backLeft] = -15;
		motor[frontRight] = motor[backRight] = -15;
		wait1Msec(100);
		motor[frontLeft] = motor[backLeft] = 0;
		motor[frontRight] = motor[backRight] = 0;
	}
	else
	{
		while(abs(nMotorEncoder[frontLeft]) < abs(distance))
		{
			motor[frontLeft] = motor[backLeft] = -1*(abs(nMotorEncoder[frontLeft] - distance) * .2 + 65);
			motor[frontRight] = motor[backRight] = -1*(abs(nMotorEncoder[frontLeft] - distance) * .2 + 65);
		}
		motor[frontLeft] = motor[backLeft] = 15;
		motor[frontRight] = motor[backRight] = 15;
		wait1Msec(100);
		motor[frontLeft] = motor[backLeft] = 0;
		motor[frontRight] = motor[backRight] = 0;
	}
}
void gyroturn(int degrees, int a, int b);
void gyroturn(int degrees)
{
	gyroturn(degrees, 1, 1);
}
void gyroturn(int degrees, int a, int b)
{
	degrees *= a;
	degrees /= b;
	SensorValue[gyro] = 0;
	if(degrees > 0) // turn right
	{
		int startTime = Time10[T4];
		int lastValue = SensorValue[gyro];
		while(abs(SensorValue[gyro]) < abs(degrees))
		{
			motor[frontLeft] = motor[backLeft] = (abs(degrees) - abs(SensorValue[gyro])) * .05 + 35;
			motor[frontRight] = motor[backRight] = -1*((abs(degrees) - abs(SensorValue[gyro])) * .05 + 35);
			lastValue = SensorValue[gyro];
			writeDebugStreamLine("%d %d", Time10[T4] - startTime, abs(SensorValue[gyro] - lastValue));
			wait1Msec(20);
			if((Time10[T4] - startTime) > 80 && abs(SensorValue[gyro] - lastValue) < 10)
				break;
		}
		motor[frontLeft] = motor[backLeft] = 15;
		motor[frontRight] = motor[backRight] = -15;
		wait1Msec(100);
		motor[frontLeft] = motor[backLeft] = 0;
		motor[frontRight] = motor[backRight] = 0;
	}
	else
	{
		int startTime = Time10[T4];
		int lastValue = SensorValue[gyro];
		while(abs(SensorValue[gyro]) < abs(degrees))
		{
			motor[frontLeft] = motor[backLeft] = -1*((abs(degrees) - abs(SensorValue[gyro])) * .05 + 35);
			motor[frontRight] = motor[backRight] = (abs(degrees) - abs(SensorValue[gyro])) * .05 + 35;
			lastValue = SensorValue[gyro];
			wait1Msec(20);
			writeDebugStreamLine("%d %d", Time10[T4] - startTime, abs(SensorValue[gyro] - lastValue))
			if((Time10[T4] - startTime) > 80 && abs(SensorValue[gyro] - lastValue) < 10)
				break;
		}
		motor[frontLeft] = motor[backLeft] = 15;
		motor[frontRight] = motor[backRight] = -15;
		wait1Msec(100);
		motor[frontLeft] = motor[backLeft] = 0;
		motor[frontRight] = motor[backRight] = 0;
	}
}
int nErrorValue;
int nLastError;
int nDerivative;
int nCycles = 0;

int nAdjustment;
int nLeftMotor;
int nRightMotor;

int nMaxSpeed = 1; //40
int nPFactor =  10; //10
int nIFactor =   0;
int nDFactor =  85; //45


int getLineErrorPosition()
{
	static int nLastPos = 0;
	int nPos = 0;
	int nNumbOfHits = 0;
	const int kThreshold1 = 350;
	const int kThreshold2 = 700;
	const int kThreshold3 = 900;

#define checkSensor(nSensor, nWeight)\
	if (SensorValue[nSensor]  > kThreshold1)\
	{\
		if (SensorValue[nSensor] > kThreshold3)\
		{nPos += 3 * nWeight; nNumbOfHits += 3;}\
		else if (SensorValue[nSensor] > kThreshold2)\
		{nPos += 2 * nWeight; nNumbOfHits += 2;}\
		else \
		{nPos += 1 * nWeight; nNumbOfHits += 1;}\
	}

	checkSensor(left2,   +70); //70
	checkSensor(left1,   +20); //30
	checkSensor(right1,  -20);
	checkSensor(right2,  -70);
	writeDebugStreamLine("%d", nPos);
	switch (nNumbOfHits)
	{
	case 0:
		// Line was not detected. Use the last detected value
		return nLastPos;

	case 1:
		break;

	default:
		nPos /= nNumbOfHits;
		break;
	}
	nLastPos = nPos;      // Save the last detected position
	return nPos;
}

void followLineClicks(int distance)
{
	distance *= 15;
	while (true)
	{
		++nCycles;
		nErrorValue = getLineErrorPosition();
		nDerivative = nErrorValue - nLastError;
		nAdjustment = ((nErrorValue * nPFactor) + (nDerivative * nDFactor))/ 100;
		nLastError  = nErrorValue;

		if (nAdjustment > 0)
		{
			nLeftMotor  = nMaxSpeed + nAdjustment;
			nRightMotor = nMaxSpeed - 10 * nAdjustment / 2; //8
			if (nRightMotor < 0)
				nRightMotor = 0;
		}
		else
		{
			nLeftMotor  = nMaxSpeed + 10 * nAdjustment / 2;
			nRightMotor = nMaxSpeed - nAdjustment;
			if (nLeftMotor < 0)
				nLeftMotor = 0;
		}
		motor[frontLeft] = motor[backLeft] = nLeftMotor * sign(distance);
		motor[frontRight] = motor[backRight] = nRightMotor * sign(distance);
		wait1MSec(15);
	}
}
int liftKP = 25, liftKI = 0, liftKD = 7;
long liftTotalError;
int liftLastError, liftLastTime = 1;
int liftPIDActive = 1;
int liftChange(int degs) // Lift Up using encoders
{
	if(SensorValue[liftLimit])
	{
		nMotorEncoder[liftRight] = 0;
	}
	int currentEncoder = nMotorEncoder[liftRight];
	int error = degs - currentEncoder; // e(t)
	liftTotalError += error;
	int dedt;
	if(time10[T2] != liftLastTime)
	{
		dedt = (error - liftLastError) / (time10[T2] - liftLastTime);
	}
	else
	{
		dedt = 0;
	}
	liftLastError = error;
	liftLastTime = time10[T2];
	if(liftPIDActive)
		motor[liftLeft] = motor[liftRight] = (liftKP * error + liftKI * liftTotalError + liftKD * dedt)/ 100;
	return degs;
}
int lastElevator = 0;
int activeElevator = 1, stopElevator = 0;
int elevatorChange(int old, int degs) // Lift Up using encoders
{
	if(degs == elevatorBottom && lastElevator != elevatorBottom) // Lift UP
	{
		if(activeElevator == 0)
		{
			stopElevator = time10[T1] + 60;
			activeElevator = 1;
		}
		motor[elevator] = 127;
		lastElevator =  degs;
		return old;
	}
	else if(degs == elevatorTop && lastElevator != elevatorTop) // Lift DOWN
	{

		if(activeElevator == 0)
		{
			stopElevator = time10[T1] + 60;
			activeElevator = 1;
		}
		motor[elevator] = -127;
		lastElevator =  degs;
		return old;
	}
	else
	{
		if(time10[T1] > stopElevator || activeElevator == 0)
		{
			motor[elevator] = 0;
			activeElevator = 0;
			lastElevator =  degs;
			return degs;
		}
		else
		{
			lastElevator =  degs;
			return old;
		}
	}
}
int lastClaw = 0;
int clawChange(int old, int degs) // Lift Up using encoders
{
	clearTimer(T3);
	if(degs == clawOpen && abs(lastClaw - SensorValue[clawPot]) > 10) // claw open
	{
		if(SensorValue[clawPot] > degs)
		{
			motor[claw] = -127;
		}
		else
		{
			motor[claw] = 0;
		}
		return degs;
	}
	else if(degs == clawClose && abs(lastClaw - SensorValue[clawPot]) > 10) // claw closed
	{
		if(SensorValue[clawPot] < degs)
		{
			motor[claw] = 127;
		}
		else
		{
			motor[claw] = 12;
		}
		return degs;
	}
	motor[claw]  = 12; // Hold Power
	return degs;
}


int oldlift = 0, oldclaw = 2300, oldelevator = 0; // Start Positions
int startTimer, endTime;
task Watchdog()
{
	while(1)
	{
		oldlift = liftChange(liftGoal);
		if(abs(motor[liftRight]) < 40)
		{
			if(startTimer == 0)
				endTime = time10[T1] + 75;
			startTimer = 1;
		}
		else
		{
			startTimer = 0;
		}
		if(startTimer && time10[T1] > endTime)
			liftDone = 1;
		else
			liftDone = 0;

		oldclaw = clawChange(oldclaw, clawGoal);
		if(oldclaw == clawGoal)
			clawDone = 1;
		else
			clawDone = 0;

		oldelevator = elevatorChange(oldelevator, elevatorGoal);
		if(oldelevator == elevatorGoal)
			elevatorDone = 1;
		else
			elevatorDone = 0;
	}

}

int stackTrigger = 0;
int taskStack = 0;
int stackFromLoader = 0;
int clInnerState = 0;
task Stacker()
{
	startTask(Watchdog);
	taskStack = taskStack;
	int lastTrigger = 0;
	while(true)
	{
		if(!resetButton)
		{
			if(lastTrigger != stackTrigger && stackTrigger == 1)
			{
				clInnerState = 0;
			}
			if(stackTrigger == 1 && curStacked < 6)
			{
				if(clInnerState == 0)
				{
					clawDone = 0;
					clawGoal = clawClose;
					clInnerState ++;
				}
				else if(clInnerState == 1)
				{
					if(clawDone)
					{
						liftDone = 0;
						liftGoal = stackLevels[curStacked];
						clInnerState ++;
					}
				}
				else if(clInnerState == 2)
				{
					if(liftDone)
					{

						clawDone = 0;
						clawGoal = clawOpen;
						clInnerState ++;
						wait1Msec(500);
					}
				}
				else if(clInnerState == 3)
				{
					if(clawDone)
					{
						liftDone = 0;
						liftDone = 0;
						if(stackFromLoader)
						{
							liftGoal = liftPreload;
						}
						else
						{
							liftGoal = liftBottom;
						}
						clInnerState++;
					}
				}
				else if(clInnerState == 4)
				{
					if(curStacked <= 2)
					{
						if(abs(nMotorEncoder[liftRight] -liftCloseClaw) < 50)
						{
							clawDone = 1;
							clawGoal = clawClose;
							clInnerState++;
						}
					}
					else
					{
						clInnerState++;
					}

				}
				else if(clInnerState == 5)
				{
					if(nMotorEncoder[liftRight] < liftCloseClaw - 25)
					{
						clawGoal = clawOpen;
						clInnerState ++;
					}

				}
				else if(clInnerState == 6)
				{
					if(liftDone)
					{
						clawGoal = clawOpen;
						stackTrigger = 0;
						clInnerState = 0;
						curStacked++;
					}
				}
				lastTrigger = stackTrigger;
			}
			wait1Msec(20);
		}
	}
}
int reverseDrive = 1;
void pre_auton()
{
	bStopTasksBetweenModes = true;
}
void basicAuto()
{
	stackTrigger = 0;
	startTask(Stacker);
	stackTrigger = 0;
	clawDone = 0;
	clawGoal = clawOpen;
	while(!clawDone) { wait1Msec(20); }
	wait1Msec(500);
	clawDone = 0;
	clawGoal = clawClose;
	while(!clawDone) { wait1Msec(20); }
	wait1Msec(2000);
	stackTrigger = 1;
	while(stackTrigger) { wait1Msec(20); }
}
void testBasic()
{
	for(int i =5; i<6; i++)
	{
		curStacked = i;
		nMotorEncoder[liftRight] = 0;
		wait1Msec(500);
		basicAuto();
		wait1Msec(1200);
	}
}
void setupLift()
{
	liftPIDActive = 0;
	motor[liftRight] = -127;
	motor[liftLeft] = -127;
	while(SensorValue[liftLimit] == 0) { wait1Msec(20); }
	nMotorEncoder[liftRight] = 0;
	motor[liftRight] = motor[liftLeft] = 0;
	return;
}
void fullAuto()
{
	startTask(Stacker);
	curStacked = 0;
	degmove(20);
	degmove(-10);
	setupLift();
	clawDone = 0;
	clawGoal = clawOpen;
	while(!clawDone) { wait1Msec(20); }
	degmove(10);
	clawDone = 0;
	clawGoal = clawClose;
	while(!clawDone) { wait1Msec(20); }
	gyroturn(180);
	motor[elevator] = 127;
	wait1Msec(500);
	motor[elevator] = 0;
	degmove(-80);
	motor[elevator] = -127;
	wait1Msec(500);
	motor[elevator] = 0;


	stackTrigger = 1;
	degmove (80);
	gyroturn(180);

	while(stackTrigger == 1) { wait1Msec(20); }
	motor[elevator] = 127;
	wait1Msec(500);
	motor[elevator] = 0;
	degmove(10);

}
int tester = 0;
task autonomous()
{
	liftGoal = 0;
	clearTimer(T1);
	/*
	0 = drive Forward 200 and back 200
	1 = lift to bottom and back to stack
	2 = claw open and close
	3 = elevator up and then down
	4 = drive turn 90 right 90 left 180 right
	5 = basic auto
	6 = pid tester
	*/
	if(tester == 0)
	{
		clawGoal = clawClose;

		lastElevator = elevatorTop;
		oldelevator = elevatorTop;
		elevatorDone = 1;
		elevatorGoal = elevatorBottom;

		motor[elevator] = 127;
		wait1Msec(650);
		motor[elevator] = 0;

		wait1Msec(350);
		while(!elevatorDone) { wait1Msec(20); }
		startTask(Watchdog);
		SensorValue[gyro] = 0;
		degmove(-65);
		wait1Msec(500);
		gyroturn(SensorValue[gyro]);
		elevatorDone = 0;
		elevatorGoal = elevatorTop;
		while(!elevatorDone) { wait1Msec(20); }
		wait1Msec(350);
		gyroturn(1675);
		SensorValue[gyro] = 0;
		degmove(-65);
		wait1Msec(250);


		degmove(25);
		elevatorGoal = elevatorBottom;
		SensorValue[gyro] = 0;
		gyroturn(1550);
		wait1Msec(500);
		SensorValue[gyro] = 0;
		degmove(-80);
		wait1Msec(250);
		elevatorDone = 0;
		elevatorGoal = elevatorTop;
		while(!elevatorDone) {}
		if(SensorValue[gyro] < 0)
			gyroturn( SensorValue[gyro] );
		degmove(-65);

		degmove(55);
		wait1Msec(250);
		elevatorGoal = elevatorBottom;
		gyroturn(780);
		wait1Msec(250);
		SensorValue[gyro] = 0;
		degmove(-40);
		wait1Msec(250);
		elevatorDone = 0;
		elevatorGoal = elevatorTop;
		while(!elevatorDone) {}
		wait1Msec(500);
		gyroturn(-850 + SensorValue[gyro]);
		wait1Msec(250);
		SensorValue[gyro] = 0;
		degmove(-70);

		degmove(25);
		elevatorGoal = elevatorBottom;
		wait1Msec(250);
		gyroturn(1600 + SensorValue[gyro]);
		wait1Msec(250);
		SensorValue[gyro] = 0;
		degmove(-75);
		wait1Msec(250);
		elevatorDone = 0;
		elevatorGoal = elevatorTop;
		while(!elevatorDone) {}
		gyroturn(SensorValue[gyro]);
		degmove(-75);
		degmove(20);
		gyroturn(400);
		degmove(80);




	}
	else if(tester == 1)
	{
		startTask(Watchdog);
		liftDone = 0;
		liftGoal = liftBottom;
		while(!liftDone) { wait1Msec(20); }
		wait1Msec(500);
		liftDone = 0;
		liftGoal = stackLevels[3];
		while(!liftDone) { wait1Msec(20); }
	}
	else if(tester == 2)
	{
		startTask(Watchdog);
		clawDone = 0;
		clawGoal = clawOpen;
		while(!clawDone) { wait1Msec(20); }
		wait1Msec(500);
		clawDone = 0;
		clawGoal = clawClose;
		while(!clawDone) { wait1Msec(20); }
	}
	else if(tester == 3)
	{
		startTask(Watchdog);
		elevatorDone = 0;
		elevatorGoal = elevatorTop;
		while(!elevatorDone) { wait1Msec(20); }
		wait1Msec(500);
		elevatorDone = 0;
		elevatorGoal = elevatorBottom;
		while(!elevatorDone) { wait1Msec(20); }
	}
	else if(tester == 4)
	{
		gyroturn(900);
		wait1Msec(500);
		gyroturn(-900);
	}
	else if(tester == 5)
	{
		curStacked = 2;
		basicAuto();
	}
	else if(tester == 6)
	{
		startTask(Watchdog);
		clawGoal = clawClose;
		for(int i = 0; i < 25; i++)
		{
			wait1Msec(20);
		}
		liftGoal = stackLevels[0];
		nMotorEncoder[liftRight] = 0;
		while(1)
		{
			wait1Msec(20);
			if(abs(motor[liftRight]) < 50)
			{
				if(startTimer == 0)
					endTime = time10[T1] + 50;
				startTimer = 1;
			}
			else
			{
				startTimer = 0;
			}
			if(startTimer && time10[T1] > endTime)
				break;
		}

		clawGoal = clawOpen;
		while(1) { wait1Msec(20); if(0) break;}
	}
	else if(tester == 7)
	{
		//testBasic();
		followLineClicks(20);
	}
	else if(tester == 8)
	{
		fullAuto();
	}
}

task usercontrol()
{
	//setupLift();
	// User control code here, inside the loop
	startTask(Stacker);
	while (true)
	{
		if(resetButton)
		{
			stackTrigger = 0;
			curStacked = 0;
		}
		if(!resetButton)
		{
			// Drive
			int left, right;
			left  = abs(vexRT[Ch3]);
			right  = abs(vexRT[Ch2]);
			left = (5*left*left + 305*left + 3624)/1000;
			right = (5*right*right + 305*right + 3624)/1000;
			if(reverseDrive == 1)
			{
				motor[frontLeft] = motor[backLeft]   = ((int) left) * reverseDrive * sign(vexRT[Ch3]);
				motor[frontRight] = motor[backRight] = ((int) right) * reverseDrive * sign(vexRT[Ch2]);
			}
			else
			{
				motor[frontLeft] = motor[backLeft]   = ((int) right) * reverseDrive * sign(vexRT[Ch2]);
				motor[frontRight] = motor[backRight] = ((int) left) * reverseDrive * sign(vexRT[Ch3]);
			}
			if(vexRT[Btn8L])
			{
				while(vexRT[Btn8L]) { wait1Msec(20); }
				reverseDrive = reverseDrive == 1 ? -1 : 1;
			}
			// Lift-Claw State Machine
			if(vexRT[Btn5D] && !stackTrigger)
			{
				clawGoal = clawClose;
			}
			else if(vexRT[Btn6D] && !stackTrigger)
			{
				clawGoal = clawOpen;
			}

			if(vexRT[Btn6U]) // Stack Ground
			{
				if(liftPIDActive)
					stackTrigger = 1;
				else
					liftPIDActive = 1;
			}
			// Manual Current Stacked Control
			if(vexRT[Btn7L])
			{
				liftPIDActive = 0;
				stackTrigger = 0;
				motor[liftLeft] = motor[liftRight] = -127;
			}
			else if(vexRT[Btn8R])
			{
				liftPIDActive = 0;
				stackTrigger = 0;
				motor[liftLeft] = motor[liftRight] = 127;
			}
			else if(stackFromLoader != -1 && stackTrigger == 0)
			{
				liftGoal = liftBottom;
			}

			// Manual Current Stacked Control
			if(vexRT[Btn5U])
			{
				while(vexRT[Btn5U]) { wait1Msec(20); }
				curStacked--;
				if(curStacked < 0)
					curStacked = 0;
			}
			if(vexRT[Btn7D])
			{
				elevatorGoal = elevatorBottom;
			}
			else if(vexRT[Btn8D])
			{
				elevatorGoal = elevatorTop;
			}
		}
		wait1Msec(20);
	}
}
