#pragma config(Sensor, in1,    clawPot,        sensorPotentiometer)
#pragma config(Sensor, in2,    gyro,           sensorGyro)
#pragma config(Sensor, in3,    elevatorPot,    sensorPotentiometer)
#pragma config(Motor,  port1,           claw,          tmotorVex393_HBridge, openLoop)
#pragma config(Motor,  port2,           elevator,      tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port3,           frontRight,    tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port4,           backRight,     tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port6,           liftLeft,      tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port7,           liftRight,     tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port8,           backLeft,      tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port9,           frontLeft,     tmotorVex393_MC29, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/*---------------------------------------------------------------------------*/
/*                                                                           */
/*        Description: Competition template for VEX EDR                      */
/*                                                                           */
/*---------------------------------------------------------------------------*/

// This code is for the VEX cortex platform
#pragma platform(VEX2)

// Select Download method as "competition"
#pragma competitionControl(Competition)

//Main competition background code...do not modify!
#include "Vex_Competition_Includes.c"

#define resetButton vexRT[Btn7R]
int sign(int x)
{
	if(x < 0)
		return -1;
	return 1;
}
/* float map(float x, float in_min, float in_max, float out_min, float out_max)
{
return (x - in_min) * (out_max - out_min) / (in_max - in_min) + out_min;
} */
void degmove(int distance)
{
	nMotorEncoder[frontLeft] = 0;
	if(distance > 0) // move forward
	{
		while(nMotorEncoder[frontLeft] < distance)
		{
			motor[frontLeft] = motor[backLeft] = 127;
			motor[frontRight] = motor[backRight] = 127;
		}
		motor[frontLeft] = motor[backLeft] = -15;
		motor[frontRight] = motor[backRight] = -15;
		wait1Msec(100);
		motor[frontLeft] = motor[backLeft] = 0;
		motor[frontRight] = motor[backRight] = 0;
	}
	else
	{
		while(nMotorEncoder[frontLeft] > distance)
		{
			motor[frontLeft] = motor[backLeft] = -127;
			motor[frontRight] = motor[backRight] = -127;
		}
		motor[frontLeft] = motor[backLeft] = 15;
		motor[frontRight] = motor[backRight] = 15;
		wait1Msec(100);
		motor[frontLeft] = motor[backLeft] = 0;
		motor[frontRight] = motor[backRight] = 0;
	}
}
void gyroturn(int degrees)
{
	SensorValue[gyro] = 0;
	if(degrees > 0) // turn right
	{
		while(SensorValue[gyro] < degrees)
		{
			motor[frontLeft] = motor[backLeft] = -127;
			motor[frontRight] = motor[backRight] = 127;
		}
		motor[frontLeft] = motor[backLeft] = 15;
		motor[frontRight] = motor[backRight] = -15;
		wait1Msec(100);
		motor[frontLeft] = motor[backLeft] = 0;
		motor[frontRight] = motor[backRight] = 0;
	}
	else
	{
		while(SensorValue[gyro] > degrees)
		{
			motor[frontLeft] = motor[backLeft] = 127;
			motor[frontRight] = motor[backRight] = -127;
		}
		motor[frontLeft] = motor[backLeft] = -15;
		motor[frontRight] = motor[backRight] = 15;
		wait1Msec(100);
		motor[frontLeft] = motor[backLeft] = 0;
		motor[frontRight] = motor[backRight] = 0;
	}
}
void liftChange(int degs) // Lift Up using encoders
{
	if(degs < nMotorEncoder[liftRight]) // Lift UP
	{
		while(nMotorEncoder[liftRight] > degs && !resetButton)
		{
			motor[liftLeft]  = 127;
			motor[liftRight]  = 127;
		}
	}
	else // Lift DOWN
	{
		while(nMotorEncoder[liftRight] < abs(degs) && !resetButton)
		{
			motor[liftRight]  = -127;
			motor[liftLeft]  = -127;
		}
	}
	motor[liftRight]  = -15; // Hold Power
	motor[liftLeft]  = -15;
	return;
}
void elevatorChange(int degs) // Lift Up using encoders
{
	if(degs < SensorValue[elevatorPot]) // Lift UP
	{
		while(SensorValue[elevatorPot] > degs && !resetButton)
		{
			motor[elevator]  = 127;
		}
	}
	else // Lift DOWN
	{
		while(SensorValue[elevatorPot] < abs(degs) && !resetButton)
		{
			motor[elevator]  = -127;
		}
	}
	motor[elevator]  = 15; // Hold Power
	return;
}
void clawChange(int degs) // Lift Up using encoders
{
	if(degs < SensorValue[clawPot]) // Claw Open
	{
		while(SensorValue[clawPot] > degs && !resetButton)
		{
			motor[claw]  = 127;
		}
		motor[claw]  = 12; // Hold Power
	}
	else // Claw Close
	{
		while(SensorValue[clawPot] < abs(degs) && !resetButton)
		{
			motor[claw]  = -127;
		}
		motor[claw]  = 0; // Hold Power
	}

	return;
}
// Config Parameters
int liftStart = 0;
int liftBottom = 0;
int liftPreload = 0;
int liftPosMultiplier = 0;
int liftStackBase = 0;
int liftGoal = 0;
int liftDone = 0;
int curStacked = 0;
task liftWatchdog()
{
	int oldGoal = liftStart;
	while(1)
	{
		if(oldGoal != liftGoal && !resetButton)
		{
			liftDone = 0;
			liftChange(liftGoal);
			liftDone = 1;
			oldGoal = liftGoal;
		}
	}
}
int clawOpen = 3500;
int clawClose = 2300;
int clawGoal = 0;
int clawDone = 0;
task clawWatchdog()
{
	int oldGoal = clawGoal;
	while(1)
	{
		if(oldGoal != clawGoal && !resetButton)
		{
			clawDone = 0;
			clawChange(clawGoal);
			clawDone = 1;
			oldGoal = clawGoal;
		}
	}
}
int elevatorGoal = 0;
int elevatorTop = 0;
int elevatorBottom = 0;
int elevatorDone = 0;
task elevatorWatchdog()
{
	int oldGoal = elevatorGoal;
	while(1)
	{
		if(oldGoal != elevatorGoal && !resetButton)
		{
			elevatorDone = 0;
			elevatorChange(elevatorGoal);
			oldGoal = elevatorGoal;
			elevatorDone = 1;
		}
	}
}
int driveDone = 0;
int driveGoal = 0;
int driveTurnGoal = 0;
task driveWatchdog()
{
	int oldGoal = driveGoal;
	int oldGyroGoal = driveTurnGoal;
	while(1)
	{
		if(oldGoal != driveGoal)
		{
			driveDone = 0;
			degmove(driveGoal - oldGoal);
			driveDone = 1;
			oldGoal = driveGoal;
		}
		if(oldGyroGoal != driveTurnGoal)
		{
			driveDone = 0;
			gyroturn(driveTurnGoal - oldGyroGoal);
			driveDone = 1;
			oldGyroGoal = driveTurnGoal;
		}
	}
}
int stackTrigger = -1;
int taskStack = 0;
int stackFromLoader = 0;
task Stacker()
{
	startTask(liftWatchdog);
	startTask(clawWatchdog);
	startTask(elevatorWatchdog);
	int clInnerState = 0;
	int lastTrigger = 0;
	while(true)
	{
		if(!resetButton)
		{
			if(lastTrigger != stackTrigger && stackTrigger == 1)
			{
				clInnerState = 0;
			}
			if(stackTrigger == 1)
			{
				if(clInnerState == 0)
				{
					clawDone = 0;
					clawGoal = clawClose;
					clInnerState ++;
				}
				else if(clInnerState == 1)
				{
					if(clawDone)
					{
						liftDone = 0;
						liftGoal = liftStackBase + liftPosMultiplier * curStacked;
						clInnerState ++;
					}
				}
				else if(clInnerState == 2)
				{
					if(liftDone)
					{
						clawDone = 0;
						clawGoal = clawOpen;
						clInnerState ++;
					}
				}
				else if(clInnerState == 3)
				{
					if(clawDone)
					{
						liftDone = 0;
						if(stackFromLoader)
						{
							liftGoal = liftPreload;
						}
						else
						{
							liftGoal = liftBottom;
						}
						clInnerState ++;
					}
				}
				else if(clInnerState == 4)
				{
					if(liftDone)
					{
						stackTrigger = 0;
						clInnerState = 0;
					}
				}
				lastTrigger = stackTrigger;
			}
			wait1Msec(20);
		}
	}
}
int elevatorPos = 0;
int reverseDrive = 1;
void pre_auton()
{
	bStopTasksBetweenModes = true;
}
void basicAuto()
{
	startTask(elevatorWatchdog);
	startTask(Stacker);

	driveDone = 0;
	driveGoal += 300;
	while(!driveDone) wait1Msec(20);

	driveDone = 0;
	driveTurnGoal -= 55;
	while(!driveDone) wait1Msec(20);

	driveDone = 0;
	driveGoal += 780;
	while(!driveDone) wait1Msec(20);

	elevatorDone = 0;
	elevatorGoal = elevatorTop;
	while(!elevatorDone) wait1Msec(20);

	/* Make Simultanous Drive and Lift*/
	taskStack = 0;
	stackTrigger = 1;

	driveDone = 0;
	driveTurnGoal += 10;
	while(!driveDone) wait1Msec(20);

	driveDone = 0;
	driveGoal -= 750;
	while(!driveDone) wait1Msec(20);

	while(taskStack == 0) wait1Msec(20);

	elevatorDone = 0;
	elevatorGoal = elevatorBottom;
	while(!elevatorDone) wait1Msec(20);

	driveDone = 0;
	driveGoal += 200;
	while(!driveDone) wait1Msec(20);
}
task autonomous()
{
	/*
	0 = drive Forward 200 and back 200
	1 = lift to bottom and back to stack
	2 = claw open and close
	3 = elevator up and then down
	4 = drive turn 90 right 90 left 180 right
	5 = basic auto
	*/
	startTask(driveWatchdog);
	startTask(liftWatchdog);
	startTask(clawWatchdog);
	startTask(elevatorWatchdog);
	int tester = 2;
	if(tester == 0)
	{
		driveDone = 0;
		driveGoal += 200;
		while(!driveDone)  wait1Msec(20);
		wait1Msec(500);
		driveDone = 0;
		driveGoal -= 200;
		while(!driveDone)  wait1Msec(20);
	}
	else if(tester == 1)
	{
		liftDone = 0;
		liftGoal = liftBottom;
		while(!liftDone)  wait1Msec(20);
		wait1Msec(500);
		liftDone = 0;
		liftGoal = liftStackBase + liftPosMultiplier * 0;
		while(!liftDone)  wait1Msec(20);
	}
	else if(tester == 2)
	{
		clawDone = 0;
		clawGoal = clawOpen;
		while(!clawDone) wait1Msec(20);
		wait1Msec(500);
		clawDone = 0;
		clawGoal = clawClose;
		while(!clawDone) wait1Msec(20);
	}
	else if(tester == 3)
	{
		elevatorDone = 0;
		elevatorGoal = elevatorTop;
		while(!elevatorDone) wait1Msec(20);
		wait1Msec(500);
		elevatorDone = 0;
		elevatorGoal = elevatorBottom;
		while(!elevatorDone) wait1Msec(20);
	}
	else if(tester == 4)
	{
		driveDone = 0;
		driveTurnGoal += 90;
		while(!driveDone) wait1Msec(20);
		wait1Msec(500);
		driveDone = 0;
		driveTurnGoal -= 90;
		while(!driveDone) wait1Msec(20);
	}
	else if(tester == 5)
	{
		basicAuto();
	}
}

task usercontrol()
{
	// User control code here, inside the loop
	startTask(liftWatchdog);
	startTask(clawWatchdog);
	startTask(elevatorWatchdog);
	startTask(Stacker);
	while (true)
	{
		if(!resetButton)
		{
			// Drive
			int left, right;
			left  = abs(vexRT[Ch3]);
			right  = abs(vexRT[Ch2]);
			left = (5*left*left + 305*left + 3624)/1000;
			right = (5*right*right + 305*right + 3624)/1000;
			motor[frontLeft] = motor[backLeft]   = ((int) left) * reverseDrive * sign(vexRT[Ch3]);
			motor[frontRight] = motor[backRight] = ((int) right) * reverseDrive * sign(vexRT[Ch2]);

			// Lift-Claw State Machine
			if(vexRT[Btn5U] && !stackTrigger)
			{
				clawGoal = clawOpen;
			}
			else if(vexRT[Btn6U]) && !stackTrigger)
			{
				clawGoal = clawClose;
			}
			if(vexRT[Btn5D]) // Stack Loader
			{
				if(stackFromLoader == 0)
				{
					stackFromLoader = 1;
				}
				else
				{
					stackTrigger = 1;
				}
			}
			else if(vexRT[Btn6D]) // Stack Ground
			{
				if(stackFromLoader == 1)
				{
					stackFromLoader = 0;
				}
				else
				{
					stackTrigger = 1;
				}
			}
			// Manual Lift
			if(vexRT[Btn7L] && !stackTrigger)
			{
				motor[liftLeft] = -127;
				motor[liftRight] = -127;
			}
			else if(vexRT[Btn8R] && !stackTrigger)
			{
				motor[liftLeft] = 127;
				motor[liftRight] = 127;
			}
			else if(!stackTrigger)
			{
				if(stackTrigger)
					liftGoal = liftBottom;
				else
					liftGoal = liftPreload;
			}
			// Elevator Toggle
			if(vexRT[Btn7D])
			{
				elevatorPos = elevatorBottom;
			}
			else if(vexRT[Btn8D])
			{
				elevatorGoal = elevatorTop;
			}
		}
	}
}
