#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, in1,    clawPot,        sensorPotentiometer)
#pragma config(Sensor, I2C_1,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_2,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_3,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Motor,  port1,           claw,          tmotorVex393_HBridge, openLoop)
#pragma config(Motor,  port2,           frontLeft,     tmotorVex393_MC29, openLoop, encoderPort, I2C_1)
#pragma config(Motor,  port3,           frontRight,    tmotorVex393_MC29, openLoop, reversed, encoderPort, I2C_2)
#pragma config(Motor,  port4,           liftLeft,      tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port5,           elevatorLeft,  tmotorVex393_MC29, openLoop, encoderPort, I2C_3)
#pragma config(Motor,  port6,           elevatorRight, tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port7,           liftRight,     tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port8,           backRight,     tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port9,           backLeft,      tmotorVex393_MC29, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/*---------------------------------------------------------------------------*/
/*                                                                           */
/*        Description: Competition template for VEX EDR                      */
/*                                                                           */
/*---------------------------------------------------------------------------*/

// This code is for the VEX cortex platform
#pragma platform(VEX2)

// Select Download method as "competition"
#pragma competitionControl(Competition)

//Main competition background code...do not modify!
#include "Vex_Competition_Includes.c"

float map(float x, float in_min, float in_max, float out_min, float out_max)
{
  return (x - in_min) * (out_max - out_min) / (in_max - in_min) + out_min;
}
void liftChange(int degs) // Lift Up using encoders
{
	if(degs < nMotorEncoder[liftRight]) // Lift UP
	{
		while(nMotorEncoder[liftRight] > degs)
		{
			motor[elevatorLeft]  = 127;
			motor[elevatorRight]  = 127;
		}
	}
	else // Lift DOWN
	{
		while(nMotorEncoder[liftRight] < abs(degs))
		{
			motor[liftRight]  = -127;
			motor[liftLeft]  = -127;
		}
	}
	motor[liftRight]  = -15; // Hold Power
	motor[liftLeft]  = -15;
	return;
}
void elevatorChange(int degs) // Lift Up using encoders
{
	if(degs < nMotorEncoder[elevatorLeft]) // Lift UP
	{
		while(nMotorEncoder[elevatorLeft] > degs)
		{
			motor[elevatorLeft]  = 127;
			motor[elevatorRight]  = 127;
		}
	}
	else // Lift DOWN
	{
		while(nMotorEncoder[elevatorLeft] < abs(degs))
		{
			motor[elevatorRight]  = -127;
			motor[elevatorLeft]  = -127;
		}
	}
	motor[elevatorRight]  = -15; // Hold Power
	motor[elevatorLeft]  = -15;
	return;
}
void clawChange(int degs) // Lift Up using encoders
{
	if(degs < SensorValue[clawPot]) // Claw Open
	{
		while(SensorValue[clawPot] > degs)
		{
			motor[claw]  = 127;
		}
	}
	else // Claw Close
	{
		while(SensorValue[clawPot] < abs(degs))
		{
			motor[claw]  = -127;
		}
	}
	motor[claw]  = 12; // Hold Power
	return;
}
void pre_auton()
{
  bStopTasksBetweenModes = true;
}

task autonomous()
{
  AutonomousCodePlaceholderForTesting();
}


// Config Parameters
int liftBottom = 0;
int liftPosMultiplier = 0;
int liftStackBase = 0;
int liftGoal = 0;
int liftDone = 0;
task liftWatchdog()
{
	int oldGoal = liftGoal;
	while(1)
	{
		if(oldGoal != liftGoal)
		{
			liftDone = 0;
			liftChange(liftGoal);
			liftDone = 1;
		}
	}
}
int clawGoal = 0;
int clawDone = 0;
task clawWatchdog()
{
	int oldGoal = clawGoal;
	while(1)
	{
		if(oldGoal != clawGoal)
		{
			clawDone = 0;
			clawChange(clawGoal);
			clawDone = 1;
		}
	}
}
int elevatorGoal = 0;
task elevatorWatchdog()
{
	int oldGoal = elevatorGoal;
	while(1)
	{
		if(oldGoal != elevatorGoal)
		{
			elevatorChange(elevatorGoal);
		}
	}
}
int clawOpen = 0;
int clawClose = 0;
int curStacked = 0;
int clState = 0;

int elevatorTop = 0;
int elevatorBottom = 0;
int elevatorPos = 0;
task usercontrol()
{
  // User control code here, inside the loop
	startTask(liftWatchdog);
	startTask(clawWatchdog);
	startTask(elevatorWatchdog);
  while (true)
  {
  	// Drive
  	float left, right;
  	left  = map((float) vexRT[Ch3], -126, 127, -1, 1);
  	right = map((float) vexRT[Ch1], -126, 127, -1, 1);
  	left  *=  left;
  	right *= right;
  	left  = map((float) vexRT[Ch3], -1, 1, -126, 127);
  	right = map((float) vexRT[Ch1], -1, 1, -126, 127);
  	motor[frontLeft] = motor[backLeft]   = (int) left;
  	motor[frontRight] = motor[backRight] = (int) right;
  	
  	// Lift-Claw State Machine
  	if(clState == 0) // Claw Open, Lift Down
  	{
  		clawGoal = clawOpen;
  		liftGoal = liftBottom;
  	}
  	else if(clState == 1) // Claw Closed, Lift Down
  	{
  		clawGoal = clawClose;
  		liftGoal = liftBottom;
  	}
  	else if(clState == 2) // Process Cone
  	{
  		clawGoal = clawClose;
  		// Lift Up
  		liftDone = 0;
  		liftGoal = liftStackBase + liftPosMultiplier * curStacked;
  		// Claw Open
  		clawDone = 0;
 			if(liftDone)
 				clawGoal = clawOpen;
  		// Lift Down
 			if(clawDone)
 				liftGoal = liftBottom;
  	}
  	if (vexRT[Btn6U])
  	{
  		clState++;
  		if(clState == 3)
  		{
  			clState = 0;
  		}
  	}
  	if (vexRT[Btn6D])
  	{
  		curStacked--;
  	}
  	// Elevator Toggle
  	if(vexRT[Btn5U])
  	{
  		while(vexRT[Btn5U]){}
  		elevatorPos = elevatorPos == 0 ? 1 : 0;
  	}
  	if(elevatorPos == 0)
  	{
  		elevatorGoal = elevatorBottom;
  	}
  	else if (elevatorPos == 1)
  	{
  		elevatorGoal = elevatorTop;
  	}
  }
}
