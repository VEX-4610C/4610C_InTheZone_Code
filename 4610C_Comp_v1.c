#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, in1,    clawPot,        sensorPotentiometer)
#pragma config(Sensor, in3,    gyro,           sensorGyro)
#pragma config(Sensor, I2C_1,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_2,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_3,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_4,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_5,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Motor,  port1,           claw,          tmotorVex393_HBridge, openLoop)
#pragma config(Motor,  port3,           frontRight,    tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port4,           backRight,     tmotorVex393_MC29, openLoop, encoderPort, I2C_2)
#pragma config(Motor,  port5,           elevator,      tmotorVex393_MC29, openLoop, encoderPort, I2C_1)
#pragma config(Motor,  port6,           liftLeft,      tmotorVex393_MC29, openLoop, encoderPort, I2C_5)
#pragma config(Motor,  port7,           liftRight,     tmotorVex393_MC29, openLoop, reversed, encoderPort, I2C_4)
#pragma config(Motor,  port8,           backLeft,      tmotorVex393_MC29, openLoop, reversed, encoderPort, I2C_3)
#pragma config(Motor,  port9,           frontLeft,     tmotorVex393_MC29, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/*---------------------------------------------------------------------------*/
/*                                                                           */
/*        Description: Competition template for VEX EDR                      */
/*                                                                           */
/*---------------------------------------------------------------------------*/

// This code is for the VEX cortex platform
#pragma platform(VEX2)

// Select Download method as "competition"
#pragma competitionControl(Competition)

//Main competition background code...do not modify!
#include "Vex_Competition_Includes.c"

#define resetButton vexRT[Btn7R]
int sign(int x)
{
	if(x < 0)
		return -1;
	return 1;
}
/* float map(float x, float in_min, float in_max, float out_min, float out_max)
{
return (x - in_min) * (out_max - out_min) / (in_max - in_min) + out_min;
} */
// Config Parameters
int liftBottom = 0;
int liftPreload = 167;
int liftPosMultiplier = -35;
int liftStackBase = 569;
int liftGoal = 0;
int liftDone = 0;
int curStacked = 0;
int stackLevels[5] = {700, 675, 565, 560, 545}

int clawOpen = 2300;
int clawClose = 2900;
int clawGoal = 2300;
int clawDone = 0;

int elevatorGoal = 0;
int elevatorTop = 0;
int elevatorBottom = 750;
int elevatorDone = 0;
void degmove(int distance)
{
	nMotorEncoder[frontLeft] = 0;
	if(distance > 0) // move forward
	{
		while(nMotorEncoder[frontLeft] < distance)
		{
			motor[frontLeft] = motor[backLeft] = 127;
			motor[frontRight] = motor[backRight] = 127;
		}
		motor[frontLeft] = motor[backLeft] = -15;
		motor[frontRight] = motor[backRight] = -15;
		wait1Msec(100);
		motor[frontLeft] = motor[backLeft] = 0;
		motor[frontRight] = motor[backRight] = 0;
	}
	else
	{
		while(nMotorEncoder[frontLeft] > distance)
		{
			motor[frontLeft] = motor[backLeft] = -127;
			motor[frontRight] = motor[backRight] = -127;
		}
		motor[frontLeft] = motor[backLeft] = 15;
		motor[frontRight] = motor[backRight] = 15;
		wait1Msec(100);
		motor[frontLeft] = motor[backLeft] = 0;
		motor[frontRight] = motor[backRight] = 0;
	}
}
void gyroturn(int degrees)
{
	SensorValue[gyro] = 0;
	if(degrees > 0) // turn right
	{
		while(SensorValue[gyro] < degrees)
		{
			motor[frontLeft] = motor[backLeft] = -127;
			motor[frontRight] = motor[backRight] = 127;
		}
		motor[frontLeft] = motor[backLeft] = 15;
		motor[frontRight] = motor[backRight] = -15;
		wait1Msec(100);
		motor[frontLeft] = motor[backLeft] = 0;
		motor[frontRight] = motor[backRight] = 0;
	}
	else
	{
		while(SensorValue[gyro] > degrees)
		{
			motor[frontLeft] = motor[backLeft] = 127;
			motor[frontRight] = motor[backRight] = -127;
		}
		motor[frontLeft] = motor[backLeft] = -15;
		motor[frontRight] = motor[backRight] = 15;
		wait1Msec(100);
		motor[frontLeft] = motor[backLeft] = 0;
		motor[frontRight] = motor[backRight] = 0;
	}
}
float liftKP = 0.3, liftKI = 0, liftKD = 0.2;
long liftTotalError;
int liftLastError, liftLastTime = 1;
int liftChange(int degs) // Lift Up using encoders
{
	int currentEncoder = nMotorEncoder[liftRight];
	int error = degs - currentEncoder; // e(t)
	liftTotalError += error;
	float dedt;
	if(time10[T2] != liftLastTime)
	{
		dedt = (error - liftLastError) / (time10[T2] - liftLastTime);
	}
	else
	{
		dedt = 0;
	}
	liftLastError = error;
	liftLastTime = time10[T2];
	motor[liftLeft] = motor[liftRight] = liftKP * error + liftKI * liftTotalError + liftKD * dedt;
	return degs;
}
int elevatorChange(int old, int degs) // Lift Up using encoders
{
	if(degs < old) // Lift UP
	{
		if(nMotorEncoder[elevator] > degs && !resetButton)
		{
			motor[elevator]  = -127;
			return old;
		}
		else
		{
			motor[elevator]  = 0;
			return degs;
		}
	}
	else if(degs > old) // Lift DOWN
	{
		if(nMotorEncoder[elevator] < degs && !resetButton)
		{
			motor[elevator]  = 127;
			return old;
		}
		else
		{
			motor[elevator]  = 0;
			return degs;
		}
	}
	motor[elevator]  = 0; // Hold Power
	return old;
}
int clawChange(int old, int degs) // Lift Up using encoders
{

	if(degs == clawOpen) // claw open
	{
		if(SensorValue[clawPot] > degs)
		{
			motor[claw] = -127;
		}
		else
		{
			motor[claw] = 0;
		}
		return degs;
	}
	else if(degs == clawClose) // claw closed
	{
		if(SensorValue[clawPot] < degs)
		{
			motor[claw] = 127;
		}
		else
		{
			motor[claw] = 12;
		}
		return degs;
	}
	motor[claw]  = 12; // Hold Power
	return old;
}


int oldlift = 0, oldclaw = 2300, oldelevator = 0; // Start Positions
void watchdog()
{
	oldlift = liftChange(liftGoal);
	if(abs(nMotorEncoder[liftLeft] - liftGoal) < 30)
		liftDone = 1;

	oldclaw = clawChange(oldclaw, clawGoal);
	if(oldclaw == clawGoal)
		clawDone = 1;

	oldelevator = elevatorChange(oldelevator, elevatorGoal);
	if(oldelevator == elevatorGoal)
		elevatorDone = 1;
}

int stackTrigger = 0;
int taskStack = 0;
int stackFromLoader = 0;
task Stacker()
{
	taskStack = taskStack;
	int clInnerState = 0;
	int lastTrigger = 0;
	while(true)
	{
		if(!resetButton)
		{
			if(lastTrigger != stackTrigger && stackTrigger == 1)
			{
				clInnerState = 0;
			}
			if(stackTrigger == 1)
			{
				if(clInnerState == 0)
				{
					clawDone = 0;
					clawGoal = clawClose;
					clInnerState ++;
				}
				else if(clInnerState == 1)
				{
					if(clawDone)
					{
						liftDone = 0;
						liftGoal = liftStackBase + liftPosMultiplier * curStacked;
						clInnerState ++;
					}
				}
				else if(clInnerState == 2)
				{
					if(liftDone)
					{
						clawDone = 0;
						clawGoal = clawOpen;
						clInnerState ++;
					}
				}
				else if(clInnerState == 3)
				{
					if(clawDone)
					{
						liftDone = 0;
						if(stackFromLoader)
						{
							liftGoal = liftPreload;
						}
						else
						{
							liftGoal = liftBottom;
						}
						clInnerState ++;
					}
				}
				else if(clInnerState == 4)
				{
					if(liftDone)
					{
						stackTrigger = 0;
						clInnerState = 0;
					}
				}
				lastTrigger = stackTrigger;
			}
			wait1Msec(20);
			watchdog();
		}
	}
}
int reverseDrive = 1;
void pre_auton()
{
	bStopTasksBetweenModes = true;
}
void basicAuto()
{
	startTask(Stacker);
}
int tester = 6;
		int startTimer = 0;
		int endTime = 0;
task autonomous()
{
	liftGoal = 0;
	clearTimer(T1);
	/*
	0 = drive Forward 200 and back 200
	1 = lift to bottom and back to stack
	2 = claw open and close
	3 = elevator up and then down
	4 = drive turn 90 right 90 left 180 right
	5 = basic auto
	6 = pid tester
	*/
	if(tester == 0)
	{
		degmove(200);
		wait1Msec(500);
		degmove(-200);
	}
	else if(tester == 1)
	{
		liftDone = 0;
		liftGoal = liftBottom;
		while(!liftDone)  watchdog();
		wait1Msec(500);
		liftDone = 0;
		liftGoal = liftStackBase + liftPosMultiplier * 0;
		while(!liftDone)  watchdog();
	}
	else if(tester == 2)
	{
		clawDone = 0;
		clawGoal = clawOpen;
		while(!clawDone) watchdog();
		wait1Msec(500);
		clawDone = 0;
		clawGoal = clawClose;
		while(!clawDone) watchdog();
	}
	else if(tester == 3)
	{
		elevatorDone = 0;
		elevatorGoal = elevatorTop;
		while(!elevatorDone) watchdog();
		wait1Msec(500);
		elevatorDone = 0;
		elevatorGoal = elevatorBottom;
		while(!elevatorDone) watchdog();
	}
	else if(tester == 4)
	{
		gyroturn(90);
		wait1Msec(500);
		gyroturn(-90);
	}
	else if(tester == 5)
	{
		basicAuto();
	}
	else if(tester == 6)
	{
		clawGoal = clawClose;
		for(int i = 0; i < 25; i++)
		{
			watchdog();
			wait1Msec(20);
		}
		liftGoal = stackLevels[3];
		nMotorEncoder[liftRight] = 0;
		while(1)
		{
			watchdog();
			wait1Msec(20);
			if(abs(motor[liftRight]) < 50)
			{
				if(startTimer == 0)
					endTime = time10[T1] + 50;
				startTimer = 1;
			}
			else
			{
				startTimer = 0;
			}
			if(startTimer && time10[T1] > endTime)
				break;
		}

		clawGoal = clawOpen;
		while(1)
			watchdog();
	}
}

task usercontrol()
{
	// User control code here, inside the loop
	startTask(Stacker);
	while (true)
	{
		if(resetButton)
		{
			stackTrigger = 0;
		}
		if(!resetButton)
		{
			// Drive
			int left, right;
			left  = abs(vexRT[Ch3]);
			right  = abs(vexRT[Ch2]);
			left = (5*left*left + 305*left + 3624)/1000;
			right = (5*right*right + 305*right + 3624)/1000;
			motor[frontLeft] = motor[backLeft]   = ((int) left) * reverseDrive * sign(vexRT[Ch3]);
			motor[frontRight] = motor[backRight] = ((int) right) * reverseDrive * sign(vexRT[Ch2]);

			// Lift-Claw State Machine
			if(vexRT[Btn5U] && !stackTrigger)
			{
				clawGoal = clawOpen;
			}
			else if(vexRT[Btn6U] && !stackTrigger)
			{
				clawGoal = clawClose;
			}
			if(vexRT[Btn5D]) // Stack Loader
			{
				while(vexRT[Btn5D]) { wait1Msec(20); }
				if(stackFromLoader == 0)
				{
					stackFromLoader = 1;
				}
				else
				{
					stackTrigger = 1;
				}
			}
			else if(vexRT[Btn6D]) // Stack Ground
			{
				while(vexRT[Btn6D]) { wait1Msec(20); }
				if(stackFromLoader == 1)
				{
					stackFromLoader = 0;
				}
				else
				{
					stackTrigger = 1;
				}
			}
			// Manual Lift
			if(vexRT[Btn7L] && !stackTrigger)
			{
				motor[liftLeft] = -127;
				motor[liftRight] = -127;
			}
			else if(vexRT[Btn8R] && !stackTrigger)
			{
				motor[liftLeft] = 127;
				motor[liftRight] = 127;
			}
			else if(!stackTrigger)
			{
				if(stackFromLoader)
					liftGoal = liftPreload;
				else
					liftGoal = liftBottom;
			}
			// Elevator Toggle
			if(vexRT[Btn7D])
			{
				elevatorGoal = elevatorBottom;
			}
			else if(vexRT[Btn8D])
			{
				elevatorGoal = elevatorTop;
			}
		}
	}
}
